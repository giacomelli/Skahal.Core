using System;
using System.Linq;
using Skahal.Infrastructure.Framework.Domain;
using Skahal.Infrastructure.Framework.Repositories;
using System.IO;
using UnityEngine;
using System.Collections.Generic;
using System.Globalization;
using Skahal.Infrastructure.Framework.Logging;
using ProtoBuf.Meta;

namespace Skahal.Infrastructure.Unity.Repositories
{
	/// <summary>
	/// Protobuf repository base.
	/// </summary>
	public abstract class ProtobufRepositoryBase<TEntity, TKey> : RepositoryBase<TEntity, TKey> where TEntity : class, IAggregateRoot<TKey>
	{
		#region Fields
		private string m_repositoryFolder;

		/// <summary>
		/// The Protobuf-net pre generate serializer.
		/// <remarks>
		/// This class is generated by the tool Skahal.Core.ProtobufCompiledSerializerGen.
		/// </remarks>
		/// <see>http://www.frictionpointstudios.com/blog/2011/3/31/using-protobuf-net-serialization-in-unity-iphone.html</see>
		/// </summary>
		private ProtobufSerializer m_serializer;
		#endregion

		#region Constructors
		/// <summary>
		/// Initializes a new instance of the <see cref="Skahal.Infrastructure.Unity.Repositories.ProtobufRepositoryBase`1"/> class.
		/// </summary>
		protected ProtobufRepositoryBase()
		{
			var entityType = typeof(TEntity);

			m_repositoryFolder = Path.Combine(Application.persistentDataPath, entityType.FullName);
		
			if(!Directory.Exists(m_repositoryFolder))
			{
				Directory.CreateDirectory(m_repositoryFolder);
			}

			m_serializer = new ProtobufSerializer ();
			LogService.Debug("{0}: using folder '{1}' as data folder.", GetType().Name, m_repositoryFolder);
		}
		#endregion

		#region Methods
		/// <summary>
		/// Finds all entities that matches the filter.
		/// </summary>
		/// <returns>The entities found.</returns>
		/// <param name="filter">Filter.</param>
		private IEnumerable<TEntity> FindAll(Func<TEntity, bool> filter)
		{
			var allIds = GetAllIds ();
	
			foreach (var id in allIds) 
			{
				using(var stream = File.OpenRead (GetFileName(id)))
				{
					var entity = (TEntity)m_serializer.Deserialize(stream, null, typeof(TEntity));

					if(filter(entity))
					{
						yield return entity;
					}
				}		
			}
		}
	
		public override TEntity FindBy (TKey key)
		{
			return FindAll(f => f.Key.Equals(key)).FirstOrDefault();
		}

		public override IEnumerable<TEntity> FindAll (int offset, int limit, Func<TEntity, bool> filter)
		{
			return FindAll (filter).Skip (offset).Take (limit);
		}

		public override long CountAll (Func<TEntity, bool> filter)
		{
			return FindAll (filter).Count ();
		}

		protected override void PersistNewItem (TEntity item)
		{
			using(var stream = File.OpenWrite (GetFileName(item.Key)))
			{
				m_serializer.Serialize(stream, item);
			}
		}

		protected override void PersistUpdatedItem (TEntity item)
		{
			PersistNewItem (item);
		}

		protected override void PersistDeletedItem (TEntity item)
		{
			File.Delete(GetFileName (item.Key));
		}

		/// <summary>
		/// Converts the key from string to TKey.
		/// </summary>
		/// <returns>The key converted.</returns>
		/// <param name="key">Key.</param>
		protected abstract TKey ConvertFrom (string key);
		#endregion
		
		#region Fields
		private string GetFileName (TKey key)
		{
			return Path.Combine(m_repositoryFolder, key + ".bin");
		}

		private TKey[] GetAllIds()
		{
			var files = Directory.GetFiles(m_repositoryFolder, "*.bin");
			LogService.Debug("{0}: {1} files found on data folder '{2}'.", GetType().Name, files.Length, m_repositoryFolder);

			var keys = new TKey[files.Length];

			for (var i = 0; i < files.Length; i++) {
				keys [i] = ConvertFrom (Path.GetFileNameWithoutExtension(files[i]));
			}

			return keys;
		}
		#endregion
	}
}

